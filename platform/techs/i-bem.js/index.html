<!DOCTYPE html><html class="ua_js_no"><head><meta http-equiv="X-UA-Compatible" content="IE=edge"/><meta charset="utf-8"/><title>i-bem</title><script>(function(e,c){e[c]=e[c].replace(/(ua_js_)no/g,"$1yes");})(document.documentElement,"className");(function(d,n){d.documentElement.className+=" ua_svg_"+(d[n]&&d[n]("http://www.w3.org/2000/svg","svg").createSVGRect?"yes":"no");})(document,"createElementNS");</script><link rel="stylesheet" href="/_index.css"/></head><body class="page page_theme_islands page_site_platform"><div class="header clearfix"><a class="logo header__logo" href="/"></a><div class="breadcrumbs header__breadcrumbs"><div class="breadcrumbs__item breadcrumbs__item_level_1"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/platform/">Платформа</a></div><div class="breadcrumbs__item breadcrumbs__item_level_2"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/platform/techs/">Технологии</a></div><div class="breadcrumbs__item breadcrumbs__item_level_3">i-bem</div></div><div class="header__item"><div class="lang-switcher"><div class="select select_mode_radio select_theme_islands select_size_m i-bem" data-bem="{&quot;select&quot;:{&quot;name&quot;:&quot;lang&quot;}}"><input class="select__control" type="hidden" name="lang" value="ru"/><button class="button button_size_m button_theme_islands button__control select__button i-bem" data-bem="{&quot;button&quot;:{}}" role="button" type="button"><span class="button__text">RU</span><i class="icon select__tick" aria-hidden="true"></i></button><div class="popup popup_target_anchor popup_theme_islands popup_autoclosable i-bem" data-bem="{&quot;popup&quot;:{&quot;directions&quot;:[&quot;bottom-left&quot;,&quot;bottom-right&quot;,&quot;top-left&quot;,&quot;top-right&quot;]}}"><div class="menu menu_size_m menu_theme_islands menu_mode_radio menu__control select__menu i-bem" data-bem="{&quot;menu&quot;:{}}" role="menu"><div class="menu-item menu-item_checked menu-item_theme_islands i-bem" data-bem="{&quot;menu-item&quot;:{&quot;val&quot;:&quot;ru&quot;}}" role="menuitem">RU</div><div class="menu-item menu-item_theme_islands i-bem" data-bem="{&quot;menu-item&quot;:{&quot;val&quot;:&quot;en&quot;}}" role="menuitem">EN</div></div></div></div></div><div class="search i-bem" data-bem="{&quot;search&quot;:{}}"><div class="search__switcher search__icon"></div><form class="form search__form control-group"><span class="input input_theme_islands input_size_l input_type_search input_has-clear search__input i-bem" data-bem="{&quot;input&quot;:{}}"><span class="input__box"><input class="input__control" name="q" type="search"/><i class="input__clear"></i></span></span><button class="button button_theme_islands button_size_l button_type_submit button_view_action button__control i-bem" data-bem="{&quot;button&quot;:{}}" role="button" type="submit"><i class="icon search__icon" aria-hidden="true"></i></button></form></div></div></div><ul class="nav"><li class="nav__item"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/platform/techs/i-bem.js/quick-start/">Quick start</a></li><li class="nav__item"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/platform/techs/i-bem.js/manual/">Manual</a></li><li class="nav__item"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/platform/techs/i-bem.js/rationale/">Rationale</a></li><li class="nav__item"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/platform/techs/i-bem.js/api/">API</a></li><li class="nav__item"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/platform/techs/i-bem.js/playground/">Playground</a></li><li class="nav__item"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/platform/techs/i-bem.js/faq/">FAQ</a></li><li class="nav__item"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/platform/techs/i-bem.js/reference/">Reference</a></li><li class="nav__item"><a class="link link__control i-bem" data-bem="{&quot;link&quot;:{}}" href="/forum/">Форум</a></li></ul><div class="main"><div class="content"><div class="post"><div><h1 id="i-bem-js-">i-bem.js: руководство пользователя</h1>
<h2 id="i-bem-js-javascript-">i-bem.js: JavaScript-фреймворк для БЭМ</h2>
<p><code>i-bem.js</code> — специализированный JavaScript-фреймворк для веб-разработки
в рамках <a href="https://ru.bem.info/method/">БЭМ-методологии</a>.</p>
<p><code>i-bem.js</code> позволяет:</p>
<ul>
<li>разрабатывать веб-интерфейс в терминах блоков, элементов, модификаторов;</li>
<li>описывать логику работы блока в декларативном стиле — как набор состояний;</li>
<li>легко интегрировать JavaScript-код с BEMHTML-шаблонами и CSS в стиле БЭМ;</li>
<li>гибко переопределять поведение библиотечных блоков.</li>
</ul>
<p><code>i-bem.js</code> не предназначен:</p>
<ul>
<li>для замены фреймворка общего назначения, подобного jQuery.</li>
</ul>
<p><strong>Краткий обзор содержания документа</strong>:</p>
<ul>
<li><a href="#intro">Общие сведения</a> о фреймворке: связь с понятиями предметной области БЭМ, краткое описание модульной структуры
фреймворка, шаблонного проекта и инструментов для сборки кода,
написанного с использованием <code>i-bem.js</code>.</li>
<li><a href="#html">Привязка JS-блоков к HTML</a> — синтаксис указания JS-блоков на
HTML-странице, типы соотношения HTML-элементов и JS-блоков.</li>
<li><a href="#decl">Декларация блока</a> — синтаксис описания JS-блоков.</li>
<li><a href="#dom">Работа с DOM-деревом</a> — API для работы с DOM-узлами блоков:
элементы, динамическое изменение DOM-дерева (AJAX).</li>
<li><a href="#events">События</a> — событийная модель <code>i-bem.js</code>: DOM-события,
БЭМ-события, делегирование событий.</li>
<li><a href="#states">Состояния блока</a> — модификаторы, триггеры на смену
состояний (установку модификаторов), инициализация экземпляров
блоков.</li>
<li><a href="#ibc">Взаимодействие блоков</a> — API для обращения из блока к другим блокам.</li>
<li><a href="#docs">Что дальше?</a> — ссылки на документацию и дополнительные материалы.</li>
</ul>
<p><a name="intro"></a></p>
<h2 id="-">Общие сведения</h2>
<p><a name="intro-bem"></a></p>
<h3 id="-javascript">БЭМ-методология и JavaScript</h3>
<p>С точки зрения БЭМ-методологии веб-интерфейс строится из независимых
<strong>блоков</strong> (внутри которых могут быть выделены <strong>элементы</strong>). И блоки,
и элементы могут иметь состояния, описываемые <strong>модификаторами</strong>.</p>
<p>Работа веб-интерфейса обеспечивается несколькими <strong>технологиями</strong>
(HTML, CSS, JS и т.д.). При использовании БЭМ-методологии вся реализация
веб-интерфейса разбита на компоненты по блокам. Описание блока в этой
схеме складывается из нескольких файлов — по одному на каждую технологию:</p>
<ul>
<li><code>my-block.css</code> — описывает внешний вид блока;</li>
<li><code>my-block.bemhtml</code> — шаблоны для генерации HTML-представления блока;</li>
<li><code>my-block.js</code> — описывает <strong>динамическое поведение</strong> блока в браузере.</li>
</ul>
<p>Фреймворк <code>i-bem.js</code> позволяет разложить клиентский JavaScript на компоненты в терминах БЭМ:</p>
<ul>
<li><strong>Блок</strong> — JS-компонент, описывающий логику работы однотипных
элементов интерфейса. Например, все кнопки могут быть реализованы
в виде блока <code>button</code>. В этом случае, в соответствии с БЭМ-методологией,
<code>button.css</code> определяет внешний вид всех кнопок, а <code>button.js</code> —
логику их работы.<br/>
На каждой странице может размещаться более одного <strong>экземпляра
блока</strong> (например, кнопки). Каждому экземпляру блока соответствует
JS-объект, динамически создаваемый в памяти браузера и хранящий
состояние данного экземпляра. JS-объект хранит ссылку на DOM-узел,
к которому привязан данный экземпляр блока.</li>
<li><strong>Элементы</strong> — DOM-узлы, вложенные в DOM-узел блока и имеющие атрибут
<code>class</code>, указывающий на их роль в БЭМ-предметной области (имя блока
и элемента). Элементы блока доступны через <a href="#elem-api">JS-API</a>
экземпляра блока.</li>
<li><strong>Модификаторы</strong> — хранят информацию о состоянии блока и его
элементов. Состояние модификаторов записывается в атрибуте <code>class</code>
на DOM-узлах блока и элементов. Управление модификаторами
производится через <a href="#mods-api">JS-API</a> экземпляра блока.</li>
</ul>
<p><a name="intro-use"></a></p>
<h3 id="-i-bem-js">Как использовать i-bem.js</h3>
<p>Фреймворк <code>i-bem.js</code> входит в состав библиотеки <a href="https://ru.bem.info/libs/bem-core/">bem-core</a>.</p>
<p>Реализация <code>i-bem.js</code> состоит из двух модулей:</p>
<ul>
<li><strong>Модуль <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/i-bem.vanilla.js">i-bem</a></strong>.<br/>
Базовая реализация JS-блока <code>i-bem</code>, от которой наследуются все блоки в
<code>i-bem.js</code>. Блок <code>i-bem</code> написан с расчетом на использование в любом
JS-окружении: как на клиенте, так и на сервере например, в
Node.js).</li>
<li><strong>Модуль <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js">i-bem__dom</a></strong>.<br/>
Базовая реализация блока, привязанного к DOM-узлу.
Рассчитан на использование на клиенте, опирается на работу браузеров с DOM. Зависит от <code>jQuery</code>.</li>
</ul>
<p>Зависимости:</p>
<ul>
<li>jQuery (только для модуля <code>i-bem__dom</code>). При использовании <code>bem-core</code> отдельная установка
jQuery не требуется.</li>
<li>Модульная система <a href="https://github.com/ymaps/modules">ymaps/modules</a>. При использовании
<a href="https://ru.bem.info/tools/bem/">bem-tools</a> с технологией <code>.browser.js</code> (и производных от нее)
эта зависимость удовлетворяется автоматически.</li>
</ul>
<p>Можно использовать <code>i-bem.js</code> как часть полного стека
БЭМ-инструментов. В этом случае свой проект удобно создавать на основе
шаблонного репозитория <a href="https://github.com/bem/project-stub/">project-stub</a>, в котором настроена автоматическая установка зависимых библиотек.</p>
<p>Если не планируется использование других технологий БЭМ-платформы,
достаточно скопировать код библиотеки <code>bem-core</code> в существующий проект.</p>
<p><a name="intro-build"></a></p>
<h3 id="-">Сборка</h3>
<p>Разработка в рамках БЭМ-методологии ведется модульно — каждый блок
программируется отдельно. Финальный исходный код веб-страниц
формируется из кода отдельных блоков с помощью процедур <strong>сборки</strong>.</p>
<p>В файловой системе блок удобно представлять в виде каталога, а реализацию блока в каждой из технологий — в виде отдельного файла:</p>
<pre><code class="lang-html">    desktop.blocks/
        my-block/
            my-block.css
            my-block.js
            my-block.bemhtml
            ...

    desktop.blocks/
        other-block/
            other-block.css
            other-block.js
            other-block.bemhtml
            ...
</code></pre>
<p>Для каждой веб-страницы код использованных на ней блоков может быть собран в единые файлы:</p>
<pre><code class="lang-html">    desktop.bundles/
        index/
            index.html
            index.css
            index.js
            ...
</code></pre>
<p>Для сборки кода результирующих веб-страниц из отдельных
описаний блоков существует два инструмента:</p>
<ul>
<li><a href="https://ru.bem.info/tools/bem/bem-tools/">bem-tools</a>;</li>
<li><a href="https://github.com/enb-make/enb">enb</a> совместно с <a href="https://github.com/enb-make/enb-modules">enb-modules</a>.</li>
</ul>
<p><a name="intro-name"></a></p>
<h3 id="-i-bem-js-">Почему i-bem.js так называется</h3>
<p>В соответствии с БЭМ-методологией, базовая JS-библиотека БЭМ-платформы изначально разрабатывалась
как особый служебный блок. Такой подход позволяет работать с базовыми библиотеками так же, как
и с обычными блоками. В частности, структурировать код в терминах элементов и модификаторов и
гибко настраивать поведение библиотеки на разных уровнях переопределения.</p>
<p>Служебным блокам в БЭМ было принято давать имена с префиксом <code>i-</code>. Таким образом, имя <code>i-bem.js</code>
читается как <em>реализация блока <code>i-bem</code> в технологии <code>JS</code></em>.</p>
<p><a name="html"></a></p>
<h2 id="-js-html">Привязка JS-блоков к HTML</h2>
<p>JavaScript-компоненты в <code>i-bem.js</code> служат для «оживления» HTML-элементов
страницы. Типовая задача JS-блока — привязать обработку определенных событий к
указанному HTML-фрагменту.</p>
<p>При разработке веб-интерфейса в <code>i-bem.js</code> первичным «каркасом»
является HTML-дерево документа. В HTML-дереве размечаются точки, к
которым привязаны интерактивные элементы интерфейса — JS-блоки.
Точка привязки JS-блока — HTML-элемент, в атрибуте <code>class</code> которого
указано имя блока, а в атрибуте <code>data-bem</code> — <a href="#html-syntax">параметры блока</a>.</p>
<p>При загрузке страницы в браузере выполняется
<a href="#init">инициализация блоков</a>. В процессе инициализации создаются
экземпляры блоков — JS-объекты для всех блоков, упомянутых в
HTML-элементах на странице. JS-объект, привязанный к HTML-элементу,
обрабатывает происходящие на нем <a href="#dom-events">DOM-события</a> и хранит
состояние данного экземпляра блока.</p>
<p><code>i-bem.js</code> дает возможность реализовать JS-компонент, не привязанный к
HTML, — <a href="#i-blocks">блок без DOM-представления</a>. Такой блок предоставляет API, аналогичное обычным JS-блокам.</p>
<p>Описанный подход привязки JavaScript-компонентов к HTML имеет следующие преимущества:</p>
<ul>
<li>естественная деградация интерфейса на клиентах с отключенным JavaScript;</li>
<li>прогрессивный рендеринг — возможность начинать отрисовку элементов интерфейса
до окончания загрузки всех данных страницы (например, изображений).</li>
</ul>
<p><a name="html-syntax"></a></p>
<h3 id="-">Синтаксис привязки блоков</h3>
<p>Чтобы привязать блок к HTML-элементу (например, <code>&lt;div&gt;...&lt;/div&gt;</code>), необходимо:</p>
<ul>
<li><strong>Объявить блок в <code>js</code> технологии.</strong><br/>
Использовать в <a href="#decl">декларации</a> имя блока в качестве первого аргумента метода BEMDOM.decl.</li>
</ul>
<pre><code class="lang-js">modules.define(&#39;my-block&#39;, [&#39;i-bem__dom&#39;], function(provide, BEMDOM){
  provide(BEMDOM.decl(this.name,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    }));
});
</code></pre>
<ul>
<li><strong>Отметить блок в HTML-дереве</strong>.<br/>
Включить имя блока в список классов HTML-элемента (атрибут <code>class</code>).</li>
</ul>
<pre><code class="lang-html"> &lt;div class=&quot;my-block&quot;&gt;...&lt;/div&gt;
</code></pre>
<ul>
<li><strong>Инициализировать экземпляр блока</strong>.<br/>
Включить класс <code>i-bem</code> в список классов HTML-элемента. Наличие этого класса позволит фреймворку инициализировать блок.</li>
</ul>
<pre><code class="lang-html">&lt;div class=&quot;my-block i-bem&quot;&gt;...&lt;/div&gt;
</code></pre>
<ul>
<li><strong>Передать параметры экземпляру блока</strong>.<br/>
Поместить параметры блока в атрибут <code>data-bem</code>. Параметры блока записываются в формате
JSON и представляют собой хэш вида: <code>имя блока</code> - <code>хэш параметров</code>. Параметры
передаются экземпляру блока <a href="#data-bem">в момент инициализации</a>.</li>
</ul>
<pre><code class="lang-html">&lt;div class=&quot;my-block i-bem&quot; data-bem=&#39;{ &quot;my-block&quot;: { &quot;name&quot;: &quot;ya&quot; } }&#39;&gt;...&lt;/div&gt;
</code></pre>
<p>Одному HTML-элементу не обязательно должен соответствовать один
экземпляр блока. Возможны следующие типы связи между блоками и HTML-элементами:</p>
<ul>
<li><a href="#html-simple">Один HTML-элемент — один JS-блок</a>;</li>
<li><a href="#html-mixes">Один HTML-элемент — несколько JS-блоков</a>;</li>
<li><a href="#distrib-block">Один JS-блок на нескольких HTML-элементах</a>;</li>
<li><a href="#i-blocks">Блоки без DOM-представления</a>.</li>
</ul>
<p><a name="html-simple"></a></p>
<h4 id="-html-js-">Один HTML-элемент — один JS-блок</h4>
<p>Самый простой и распространенный способ привязки блоков к HTML.</p>
<p><strong>Пример:</strong> HTML-элемент <code>div</code>, на котором размещен блок <code>my-block</code>.
Параметры блока: пустой список <code>{}</code>.</p>
<pre><code class="lang-html">&lt;div class=&quot;my-block i-bem&quot; data-bem=&#39;{ &quot;my-block&quot;: {} }&#39;&gt;
    ...
&lt;/div&gt;
</code></pre>
<p><a name="html-mixes"></a></p>
<h4 id="-html-js-">Один HTML-элемент — несколько JS-блоков</h4>
<p>Техника размещения нескольких блоков на одном HTML-элементе в БЭМ-методологии называется <strong>микс</strong>.</p>
<p><strong>Пример:</strong> HTML-элемент <code>div</code>, на котором размещены:</p>
<ul>
<li>блок <code>user</code> с параметром <code>name</code>: <code>pushkin</code>;</li>
<li>блок <code>avatar</code> с параметром <code>img</code>: <code>http://...</code>.</li>
</ul>
<pre><code class="lang-html">&lt;div class=&quot;user avatar i-bem&quot;
    data-bem=&#39;{
        &quot;user&quot;: { &quot;name&quot;: &quot;pushkin&quot; },
        &quot;avatar&quot;: { &quot;img&quot;: &quot;http://...&quot; }
     }&#39;&gt;
     ...
&lt;/div&gt;
</code></pre>
<p><a name="distrib-block"></a></p>
<h4 id="-js-html-">Один JS-блок на нескольких HTML-элементах</h4>
<p>Такой дизайн позволяет прозрачно реализовывать блоки, состоящие из
нескольких компонентов, состояние которых должно быть согласовано. Например, виджет «вкладки»,
где клик по заголовку вкладки (первый HTML-элемент), меняет содержимое вкладки (второй HTML-элемент).
Другой пример: маркер, обозначающий точку на карте (первый элемент),
и связанное с ним описание точки в списке рядом с картой (второй элемент).</p>
<p>Чтобы привязать экземпляр блока к нескольким HTML-элементам, в параметрах блока необходимо
указать одинаковое значение <code>id</code> для всех связанных с блоком HTML-элементов.
В качестве значения <code>id</code> может выступать произвольная строка.</p>
<p><strong>Пример:</strong> Экземпляр блока <code>notebook</code> привязан к HTML-элементам <code>div</code> и <code>span</code>.
В параметрах блока указан общий <code>id</code> — <code>maintab</code>.</p>
<pre><code class="lang-html">&lt;div class=&quot;notebook i-bem&quot; data-bem=&#39;{ &quot;notebook&quot;: { &quot;id&quot;: &quot;maintab&quot; }}&#39;&gt;
&lt;/div&gt;
...
&lt;span class=&quot;notebook i-bem&quot; data-bem=&#39;{ &quot;notebook&quot;: { &quot;id&quot;: &quot;maintab&quot; }}&#39;&gt;
&lt;/span&gt;
</code></pre>
<p>В результате при инициализации блоков создается один JS-объект, поле
<a href="#domElem"><code>{jQuery} domElem</code></a> которого содержит ссылки на оба DOM-узла.</p>
<p>Идентификатор <code>id</code> используется <em>только в момент инициализации</em>
экземпляра блока. Значение <code>id</code> должно быть уникальным в пределах
экземпляров одного блока, в рамках одной <a href="#init-wave">волны инициализации</a>.</p>
<p><a name="i-blocks"></a></p>
<h4 id="-dom-">Блоки без DOM-представления</h4>
<p>Инфраструктурный код, решающий общие задачи интерфейса (связь с
бэкэндом, общие вычисления и т.п.), при работе с <code>i-bem.js</code> можно
оформлять в виде блока, как и весь прочий JS-код. Чтобы не приходилось привязывать
такие блоки к HTML-дереву искусственно, <code>i-bem.js</code> предоставляет
возможность создавать блоки без DOM-представления.</p>
<p>Блоки без DOM-представления:</p>
<ul>
<li>не указываются в HTML-коде страницы;</li>
<li>декларируются как <a href="#bem-decl">доопределение модуля <code>i-bem</code></a>, а не <code>i-bem__dom</code>
(как блоки с DOM-представлением);</li>
<li>должны быть <a href="#init-bem">инициализированы явно</a>.</li>
</ul>
<p><a name="data-bem"></a></p>
<h3 id="-">Синтаксис передачи параметров</h3>
<p>Параметры блока хранятся в атрибуте <code>data-bem</code> HTML-элемента
и передаются блоку в момент инициализации. Параметры позволяют
модифицировать поведение экземпляра блока, привязанного к данному
HTML-элементу.</p>
<p>В значении атрибута <code>data-bem</code> указываются параметры <em>всех JS-блоков, размещенных на данном узле</em>.
Параметры передаются в формате JSON в виде хэша:</p>
<ul>
<li>ключ — <code>{String}</code>, имя блока;</li>
<li>значение — <code>{Object}</code>, параметры данного блока. Если данному экземпляру блока не требуются
параметры, указывается пустой хэш <code>{}</code>.</li>
</ul>
<p>Значение атрибута <code>data-bem</code> должно содержать валидный JSON.</p>
<p>Такой формат параметров продиктован следующими соображениями:</p>
<ul>
<li>Указание имени блока в параметрах позволяет избежать необходимости
парсить значение атрибута <code>class</code>, что упрощает и ускоряет
инициализацию блоков.</li>
<li>Это же решение позволяет размещать несколько блоков на одном
HTML-элементе без необходимости множить атрибуты элемента.</li>
</ul>
<p><a name="decl"></a></p>
<h2 id="-">Декларация блока</h2>
<p>JS-реализация блока описывает поведение определенного класса элементов веб-интерфейса. В конкретных
интерфейсах каждый блок может быть представлен несколькими экземплярами. Каждый экземпляр блока реализует
функциональность всего класса и имеет собственное состояние, независимое от остальных.</p>
<p>В терминах парадигмы объектно-ориентированного программирования:</p>
<ul>
<li>блок — класс;</li>
<li>экземпляр блока — экземпляр класса.</li>
</ul>
<p>В соответствии с ООП, вся функциональность блока реализуется модульно в методах класса <em>(=блока)</em>.</p>
<p>Методы блока подразделяются на:</p>
<ul>
<li>методы экземпляра блока;</li>
<li>статические методы.</li>
</ul>
<p>Код блока в <code>i-bem.js</code> принято называть <strong>декларацией</strong>, чтобы подчеркнуть принятый
в БЭМ декларативный стиль программирования. Поведение блока программируется
в декларативном стиле в виде утверждений: <code>набор условий</code> — <code>реакция блока</code>.</p>
<p><a name="decl-syntax"></a></p>
<h3 id="-">Синтаксис декларации</h3>
<p>Чтобы задекларировать новый JS-блок <strong>с DOM-представлением</strong> (привязанный к HTML-элементу), необходимо доопределить <a href="https://github.com/ymaps/modules">ymaps</a>-модуль <code>i-bem__dom</code>.</p>
<p>Блоки декларируются с помощью метода <code>decl</code>, принимающего три
параметра:</p>
<ol>
<li>Имя блока <code>{String}</code> или <a href="#decl-selector">описание блока</a> <code>{Object}</code>.</li>
<li>Методы экземпляра блока — <code>{Object}</code>.</li>
<li>Статические методы — <code>{Object}</code>.</li>
</ol>
<pre><code class="lang-js">modules.define(&#39;my-block&#39;, [&#39;i-bem__dom&#39;], function(provide, BEMDOM){
  provide(BEMDOM.decl(this.name,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    }));
});
</code></pre>
<p><strong>NB</strong> С точки зрения модульной системы <a href="https://github.com/ymaps/modules">ymaps</a>, декларации разных
блоков представляют собой переопределение одного и того же модуля
<code>i-bem__dom</code>. Однако, с точки зрения <code>i-bem.js</code>, таким образом создаются
<em>разные объекты</em> для построения экземпляров блоков.</p>
<p><a name="bem-decl"></a>
Блоки, не имеющие DOM-представления, декларируются как доопределение <a href="https://github.com/ymaps/modules">ymaps</a>-модуля <code>i-bem</code>.
Для декларации используется метод <code>decl</code>, принимающий те же параметры,
что и метод <code>decl</code> модуля <code>i-bem__dom</code>:</p>
<pre><code class="lang-js">modules.define(&#39;my-block&#39;, [&#39;i-bem&#39;], function(provide, BEM) {

provide(BEM.decl(this.name,
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    })
);

});
</code></pre>
<hr>
<p><strong>NB</strong> Оформлять инфраструктурный код в виде блока без
DOM-представления удобно, если в нем планируется использовать API
БЭМ-блоков (состояния, выражаемые модификаторами, БЭМ-события и
т. п.). Если использовать БЭМ-предметную область не планируется,
инфраструктурный код можно оформлять в виде <a href="https://github.com/ymaps/modules">ymaps</a>-модуля.</p>
<p><strong>Пример:</strong></p>
<pre><code class="lang-js">modules.define(&#39;router&#39;, function(provide) {

provide({
    route : function() { /* ... */ }
});

});
</code></pre>
<hr>
<p><a name="decl-selector"></a></p>
<h3 id="-">Описание блока в декларации</h3>
<p>Первый параметр метода <code>decl</code> представляет собой описание блока, в
котором будут применяться объявленные в декларации методы. Описание
обязательно содержит имя блока и может дополнительно содержать:</p>
<ul>
<li>ограничение сферы действия декларации определенной модификацией
блока;</li>
<li>список родительских блоков, методы которых должен наследовать данный
блок.</li>
</ul>
<p>Описание может быть задано в одной из двух форм:</p>
<ul>
<li><strong>Имя блока — строка</strong>.<br/>
 Объявленные методы будут применяться во всех экземплярах блока независимо от их состояний (модификаторов).<br/>
<strong>Пример:</strong> Декларация методов для блока <code>button</code>.
```js
modules.define(&#39;button&#39;, [&#39;i-bem&#39;], function(provide, BEMDOM) {</li>
</ul>
<p>provide(BEMDOM.decl(this.name,
    {
        /<em> методы экземпляра </em>/
    },
    {
        /<em> статические методы </em>/
    })
);</p>
<p>});</p>
<pre><code>
* **Описание блока — хэш**.&lt;br/&gt;
Содержит имя (и значение) модификатора. Объявленные методы будут применяться только к тем
экземплярам блока, у которых присутствует данный модификатор (с
указанным значением).&lt;br/&gt;
**Пример:** Декларация методов для блока `button` с модификатором
`type` в значении `link` (описывает поведение псевдокнопок):
```js
modules.define(&#39;button&#39;, [&#39;i-bem&#39;], function(provide, Button) {

provide(Button.decl({ modName : &#39;type&#39;, modVal : &#39;link&#39; },
    {
        /* методы экземпляра */
    },
    {
        /* статические методы */
    })
);

});
</code></pre><p><strong>NB</strong> Cтатические методы блока будут доступны всем его экземплярам <em>вне зависимости от значений модификаторов</em>.
Модификаторы являются свойствами экземпляров блоков, а статические методы принадлежат классу
блока и не учитывают состояния модификаторов.</p>
<p><a name="inher"></a></p>
<h3 id="-">Наследование блока</h3>
<p>Одна и та же функциональность может быть востребована в нескольких блоках проекта.
Например, разные блоки могут обращаться за данными к бэкенду, используя AJAX,
или совершать однотипные операции с DOM-деревом и т.д. Чтобы избежать ненужных повторов в коде,
общую функциональность можно инкапсулировать в виде модулей, а затем добавлять к блокам.</p>
<p>Наследование позволяет повторно использовать функциональность блока, расширяя ее новой логикой.
В <code>i-bem.js</code> доступно несколько механизмов наследования. Выбор конкретного механизма зависит от специфики создаваемого блока.</p>
<p><a name="inher-simple"></a></p>
<h4 id="-">Простое наследование</h4>
<p>В случае простого наследования создаваемый блок объявляется как наследник существующего. Для этого нужно:</p>
<ol>
<li>Указать базовый блок в зависимостях модульной системы.</li>
<li>Передать ссылку на базовый блок в специальном поле декларации <code>baseBlock</code>.</li>
</ol>
<pre><code class="lang-js">modules.define(&#39;ablock&#39;, [&#39;i-bem__dom&#39;], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {}));

});

modules.define(&#39;bblock&#39;, [&#39;i-bem__dom&#39;, &#39;ablock&#39;], function(provide, BEMDOM, ABlock) {

provide(BEMDOM.decl({ block : this.name, baseBlock : ABlock ));

});
</code></pre>
<p>Такой механизм позволяет использовать методы родительского блока внутри производного.
Для доступа к методам родителя служит специальное поле контекста <code>this.__base</code>.</p>
<p><strong>NB</strong> В <code>i-bem</code> можно создавать цепочки наследования – блок наследуется от другого,
который, в свою очередь, наследуется от третьего и т.д.</p>
<p><a name="inher-over"></a></p>
<h4 id="-">Доопределение существующего блока</h4>
<p>При наследовании можно сохранить основную функциональность базового блока.
Для этого можно <strong>доопределить</strong> базовый блок новым на уровне переопределения проекта.
Создаваемый в проекте блок реализует собственную логику, дополняющую или переопределяющую логику базового.
Такая схема наследования часто используется при работе с библиотечными блоками.</p>
<p>Чтобы доопределить существующий блок нужно создать новый блок с тем же именем.
Пересекающиеся методы и модификаторы будут определены в соответствие с декларацией нового блока.</p>
<pre><code class="lang-js">modules.define(&#39;ablock&#39;, [&#39;i-bem__dom&#39;], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {})); // Объявляем базовый блок

});

modules.define(&#39;ablock&#39;, function(provide, ABlock) {

provide(ABlock.decl({})); // Доопределяем базовый блок

});
</code></pre>
<p><a name="inher-over-modifier"></a></p>
<h5 id="-">Добавление модификатора к существующему блоку</h5>
<p>В соответствии с БЭМ-методологией состояния блока должны описываться <a href="#modifiers">модификаторами</a>.
Поэтому расширение функциональности блока часто предполагает реализацию поддержки новых модификаторов.</p>
<p>Для добавления модификатора необходимо передать методу <code>decl</code> доопределяемого блока:</p>
<ul>
<li>хеш с ключами <code>modName</code> и <code>modVal</code>. Значением для <code>modName</code> служит строка – имя модификатора. Значением <code>modVal</code> – строка со значением модификатора.</li>
<li>хеш с реализацией методов, которые будут доступны для блока с соответствующим модификатором. Пересекающиеся методы будут переопределены методами из хеша.</li>
</ul>
<pre><code class="lang-js">modules.define(&#39;ablock&#39;, [&#39;i-bem__dom&#39;], function(provide, BEMDOM) {

provide(BEMDOM.decl(this.name, {})); // Объявляем базовый блок

});

modules.define(&#39;ablock&#39;, function(provide, ABlock) {

provide(ABlock.decl({ modName : &#39;m1&#39;, modVal : &#39;v1&#39; }, {})); // Доопределяем базовый блок с модификтором _m1_v1

});
</code></pre>
<p><a name="inher-mixins"></a></p>
<h4 id="-">Блоки-миксы</h4>
<p>В <code>i-bem.js</code> для добавления востребованной функциональности к блокам, используется специальный
тип блоков – <strong>блоки-миксы</strong>. Главная особенность блоков-миксов состоит в том, что они не участвуют
в цепочке наследования. Это позволяет примешивать реализованную в них функциональность к другим блокам
без риска нарушения их связей с родительскими блоками (вызов базовых методов (<code>this.__base</code>) и т.д.).</p>
<p><a name="inher-mixins-declwithmix"></a></p>
<h5 id="-">Описание блока-микса в декларации</h5>
<p>Чтобы подмешать к блоку один или несколько блоков-миксов, необходимо в декларации блока присвоить
значение опциональному полю <code>baseMix</code>. Значением служит массив имен примешиваемых блоков-миксов:</p>
<pre><code class="lang-js">modules.define(&#39;my-block&#39;, [&#39;i-bem__dom&#39;], function(provide, BEMDOM) {

provide(BEMDOM.decl({ block: this.name, baseMix: [&#39;foo&#39;, &#39;bar&#39;]},
    { /* методы экземпляра */ },
    { /* статические методы */ }
}));

});
</code></pre>
<p><a name="inher-mixins-mixindecl"></a></p>
<h5 id="-">Декларация блока-микса</h5>
<p>В качестве блоков-миксов можно использовать только блоки, созданные с помощью <code>declMix</code>.
Этот метод принимает декларацию блока в формате, аналогичном методу <code>decl</code>:</p>
<pre><code class="lang-js">modules.define(&#39;mymix&#39;, [&#39;i-bem__dom&#39;], function(provide, BEMDOM) {

provide(BEMDOM.declMix({ block: &#39;mymix&#39; },
    { /* методы экземпляра */ },
    { /* статические методы */ }
}));

});
</code></pre>
<p><strong>NB</strong> Первым аргументом в декларации блока-микса всегда выступает строка – имя блока.
Это связано с тем, что для блоков-миксов не предполагаются возможности использования модификаторов или примешивания блоков.</p>
<p><a name="context"></a></p>
<h3 id="-">Контекст</h3>
<p><strong>Методы экземпляра блока</strong> исполняются в контексте JS-объекта
экземпляра блока. Соответственно, ключевое слово <code>this</code> в методах
экземпляра блока ссылается на JS-объект <strong>экземпляра блока</strong>.</p>
<p><strong>Статические методы</strong> исполняются в контексте JS-объекта,
соответствующего классу блока. Соответственно, ключевое слово <code>this</code>
в статических методах блока ссылается на <strong>класс блока</strong>, а не на
экземпляр.</p>
<p>Контекст содержит зарезервированные поля:</p>
<ul>
<li><code>this.__self</code>: cсылается на статические методы класса, к которому
принадлежит экземпляр. Определен в методах экземпляра блока. Для
статических методов не имеет смысла и не определен.<br/>
<strong>Пример:</strong> Вызов статического метода <code>staticMethod</code> в методе
<code>onEvent</code> экземпляра блока <code>my-block</code>.</li>
</ul>
<pre><code class="lang-js">BEMDOM.decl(&#39;my-block&#39;, {
    onEvent: function() {
        this.__self.staticMethod(); // вызов статического метода
        this.doMore();
    },
    {
        staticMethod: function() { /* ... */ }; // определение статического метода
    }
});
</code></pre>
<ul>
<li><code>this.__base</code>: cсылается на реализацию метода в базовом классе, от которого наследуется данный.
Позволяет выполнить <code>super call</code>. Определен в методах экземпляра
блока и в статических методах блока.<br/>
<strong>Пример:</strong> вызов (и модификация) метода <code>_onClick</code> родительского класса (базовой реализации метода в классе <code>button</code>).</li>
</ul>
<pre><code class="lang-js">BEMDOM.decl({ block: &#39;my-button&#39;, baseBlock: &#39;button&#39; }, {
    _onClick: function() {
        this.__base();
        this.doMore();
    }
);
</code></pre>
<hr>
<p><strong>NB</strong> Так как блоки-миксы не участвуют в цепочке наследования, внутри них нельзя использовать <code>__base</code> для обращения к родительскому блоку.</p>
<hr>
<p><strong>NB</strong> При разработке блоков с использованием <code>i-bem.js</code> внутренним
методам блока, не предназначенным для использования извне, принято
давать имена, начинающиеся с символа подчеркивания. Например,
<code>_onClick</code>.</p>
<hr>
<p><a name="dom"></a></p>
<h2 id="-dom-">Работа с DOM-деревом</h2>
<p><a name="domElem"></a></p>
<h3 id="dom-">DOM-узел экземпляра блока</h3>
<p>Все экземпляры блоков, привязанные к DOM-дереву, содержат в поле
<code>{jQuery} this.domElem</code> jQuery-объект, ссылающийся на один или
несколько DOM-узлов, с которыми связан данный экземпляр блока.</p>
<p><a name="elem-api"></a></p>
<h3 id="-">Элементы</h3>
<p>БЭМ-элементы блоков представлены в <code>i-bem.js</code> как DOM-узлы, вложенные
в DOM-узел экземпляра блока. Для обращения к DOM-узлам элементов и
работы с их модификаторами, следует использовать API, предоставляемый
экземпляром блока.</p>
<p>Экземпляр блока предоставляет два метода для обращения к элементам данного экземпляра:</p>
<ul>
<li>Кэширующий доступ: <code>elem(elems, [modName], [modVal])</code>. Элемент,
полученный таким образом, не требуется сохранять в переменную.</li>
</ul>
<pre><code class="lang-js">BEMDOM.decl(&#39;link&#39;, {
    setInnerText: function() {
        this.elem(&#39;inner&#39;).text(&#39;Текст ссылки&#39;);
        /* ... */
        this.elem(&#39;inner&#39;).text(&#39;Другой текст&#39;);
    }
);
</code></pre>
<ul>
<li>Некэширующий доступ: <code>findElem(elems, [modName], [modVal])</code>.</li>
</ul>
<pre><code class="lang-js">BEMDOM.decl(&#39;link&#39;, {
    setInnerText: function() {
        var inner = this.findElem(&#39;inner&#39;);
        inner.text(&#39;Текст ссылки&#39;);
        /* ... */
        inner.text(&#39;Другой текст&#39;);
    }
});
</code></pre>
<p>При <a href="#dynamic">динамическом добавлении и удалении элементов блока</a> может
возникнуть необходимость сброса кэша элементов. Для этого предназначен
метод <code>dropElemCache(&#39;elements&#39;)</code>. В качестве параметра указывается
разделенный пробелами список имен элементов, кэш которых нужно сбросить:</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;attach&#39;, {
    clear: function() {
        BEMDOM.destruct(this.elem(&#39;control&#39;));
        BEMDOM.destruct(this.elem(&#39;file&#39;));
        return this.dropElemCache(&#39;control file&#39;);
    }
});
</code></pre>
<p>Полное описание API для работы с элементами содержится в
исходном коде модуля <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js">i-bem__dom</a>.</p>
<p><a name="dynamic"></a></p>
<h3 id="-dom-">Динамическое обновление блоков и элементов в DOM-дереве</h3>
<p>В современных интерфейсах зачастую необходимо создавать новые
фрагменты DOM-дерева и заменять старые в процессе работы (AJAX). В
<code>i-bem.js</code> предусмотрены следующие функции для добавления и замены
фрагментов DOM-дерева.</p>
<ul>
<li><p>Добавить DOM-фрагмент:</p>
<ul>
<li><code>append</code> —  в конец указанного контекста;</li>
<li><code>prepend</code> — в начало указанного контекста;</li>
<li><code>before</code> — перед указанным контекстом;</li>
<li><code>after</code> — после указанного контекста;</li>
</ul>
</li>
<li><p>Заместить DOM-фрагмент:</p>
<ul>
<li><code>update</code> —  внутри указанного контекста;</li>
<li><code>replace</code> — заменить указанный контекст новым DOM-фрагментом.</li>
</ul>
</li>
</ul>
<p>Все функции автоматически выполняют <a href="#init-ajax">инициализацию блоков на обновленном фрагменте DOM-дерева</a>.</p>
<p>Чтобы упростить создание БЭМ-сущностей на обновляемых фрагментах
DOM-дерева, можно использовать шаблонизатор
<a href="https://ru.bem.info/technology/bemhtml/current/intro/">BEMHTML</a>, подключив
его в качестве <a href="https://github.com/ymaps/modules">ymaps</a>-модуля. БЭМ-сущности описываются в формате
<a href="https://ru.bem.info/technology/bemjson/current/bemjson/">BEMJSON</a>
непосредственно в коде блока. Функция <code>BEMHTML.apply</code> генерирует
HTML-элементы по BEMJSON-описанию в соответствии с правилами
именования БЭМ.</p>
<p><strong>Пример:</strong> В методе <code>_updateFileElem</code> блока <code>attach</code> выполняются
удаление элемента <code>file</code>, если он существовал, и генерация нового
элемента с помощью функции <code>BEMHTML.apply</code>:</p>
<pre><code class="lang-js">modules.define(
    &#39;i-bem__dom&#39;,
    [&#39;BEMHTML&#39;, &#39;strings__escape&#39;],
    function(provide, BEMHTML, escape, BEMDOM) {

provide(BEMDOM.decl(&#39;attach&#39;, {
    _updateFileElem : function() {
        var fileName = extractFileNameFromPath(this.getVal());
        this.elem(&#39;file&#39;).length &amp;&amp; BEMDOM.destruct(this.elem(&#39;file&#39;));
        BEMDOM.append(
            this.domElem,
            BEMHTML.apply({
                block : &#39;attach&#39;,
                elem : &#39;file&#39;,
                content : [
                    {
                        elem : &#39;icon&#39;,
                        mods : { file : extractExtensionFromFileName(fileName) }
                    },
                    { elem : &#39;text&#39;, content : escape.html(fileName) },
                    { elem : &#39;clear&#39; }
                ]
            }));
        return this.dropElemCache(&#39;file&#39;);
    }
}));

});
</code></pre>
<p><a name="events"></a></p>
<h2 id="-">События</h2>
<p>В <code>i-bem.js</code> поддерживается два вида событий:</p>
<p><a name="dom-events"></a></p>
<ul>
<li><strong>DOM-событие</strong> — JavaScript-событие на DOM-узле, связанном с
блоком. Отражает взаимодействие пользователя с интерфейсом (клик,
наведение мыши, ввод текста и т.п.). DOM-событие обычно обрабатывает
тот экземпляр блока, на DOM-узле которого оно возникло.</li>
<li><strong>БЭМ-событие</strong> — собственное событие, генерируемое
блоком. Позволяет организовать API для
<a href="#ibc">взаимодействия с блоком</a>. БЭМ-событие обычно обрабатывает
экземпляр блока, отслеживающий состояние других блоков, на которых
генерируются события.</li>
</ul>
<p>Планируя архитектуру интерфейса, нужно учитывать, что DOM-события
следует использовать только во <em>внутренних</em> процедурах блока. Для
взаимодействия блока с <em>внешней</em> средой (другими блоками),
предназначены БЭМ-события.</p>
<p><strong>NB</strong> Работа с DOM-событиями полностью реализована средствами
фреймворка jQuery.</p>
<p><a name="delegated-events"></a></p>
<h3 id="-">Делегирование событий</h3>
<p>Обработка БЭМ- и DOM-событий может быть <strong>делегирована</strong> контейнеру
(всему документу или конкретному DOM-узлу). В этом случае контейнер
служит точкой обработки событий, возникающих на любом из
дочерних узлов контейнера, даже если в момент подписки на события
некоторые из дочерних узлов еще не существовали.</p>
<p>Блок меню может содержать вложенные блоки (или элементы, в
зависимости от конкретной реализации блока): например, пункты меню. Обработку
кликов на пунктах меню имеет смысл делегировать самому блоку
меню. Это, во-первых, позволяет сэкономить затраты ресурсов на
подписку на события (дешевле подписаться на одно событие контейнера,
чем на много событий элементов). Во-вторых, дает возможность более
гибко изменять состав меню: добавлять и удалять пункты, не выполняя
при этом подписку на события добавленных пунктов меню и отмену
подписки на события удаленных.</p>
<ul>
<li><a href="#dom-events-delegated">Делегирование DOM-событий</a> можно
использовать для обработки DOM-событий, происходящих на DOM-узле
экземпляра блока или на DOM-узлах его элементов. Делегирование
DOM-событий может выполняться либо для всех экземпляров блоков
данного типа в пределах документа, либо только для экземпляров
блоков внутри указанного контекста (фрагмента HTML-дерева).</li>
</ul>
<p>Контейнером, которому делегируется обработка DOM-событий, всегда
выступает <code>window.document</code>.</p>
<ul>
<li><a href="#bem-events-delegated">Делегирование БЭМ-событий</a> следует
использовать для обработки событий на <em>экземплярах блоков</em>,
содержащихся внутри указанного DOM-узла.</li>
</ul>
<p>Контейнером, которому делегируется обработка БЭМ-событий, может
служить <strong>произвольный DOM-узел</strong>. По умолчанию в качестве
контейнера выступает весь документ (<code>window.document</code>). Часто блок
обрабатывает БЭМ-события вложенных блоков, тогда в качестве
контейнера следует указать DOM-узел блока-обработчика
<a href="#domElem"><code>this.domElem</code></a>.</p>
<p>Полный список хелперов для подписки на делегированные события
можно найти в исходном коде модуля <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js">i-bem__dom</a>.</p>
<h3 id="dom-">DOM-события</h3>
<p>Для подписки на DOM-события на узлах, связанных с блоком или
элементом, используется метод экземпляра блока <code>bindTo([elem], event, handler)</code>.</p>
<p><strong>Пример:</strong> В момент <a href="#init">инициализации экземпляра блока</a>
<code>my-block</code> выполняется подписка на событие <code>click</code>, при наступлении
которого блок выставляет себе <a href="#modifier">модификатор</a> <code>size</code> в
значение <code>big</code>.</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;my-block&#39;, {
    onSetMod : {
        &#39;js&#39; : {
            &#39;inited&#39;: function() {
                this.bindTo(&#39;click&#39;, function(e) {
                    var domElem = $(e.currentTarget); // DOM-элемент, на котором слушается событие
                                                      // в данном случае то же, что this.domElem
                    this.setMod(&#39;size&#39;, &#39;big&#39;);
                });
            }
        }
    }
});
</code></pre>
<p><strong>Пример:</strong> При <a href="#init">инициализации экземпляра блока</a> <code>my-form</code> выполняется
подписка на событие <code>click</code> элемента <code>submit</code>, при наступлении
которого будет вызван метод экземпляра блока <code>_onSubmit</code>.</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;my-block&#39;, {
    onSetMod : {
        &#39;js&#39; : {
            &#39;inited&#39;: function() {
                this.bindTo(&#39;submit&#39;, &#39;click&#39;, function(e) {
                    var domElem = $(e.currentTarget); // DOM-элемент, на котором слушается событие
                                                      // в данном случае то же, что this.elem(&#39;submit&#39;)
                    this._onSubmit();
                });
            }
        }
    },

    _onSubmit : function() { /* ... */ }
});
</code></pre>
<p><strong>NB</strong> Функция-обработчик выполняется в контексте того экземпляра
блока, в котором возникло событие.</p>
<p><strong>Удаление подписки</strong> на DOM-события выполняется автоматически при
уничтожении экземпляра блока. Если необходимо удалить подписку вручную
в процессе работы блока, следует использовать метод
<code>unbindFrom([elem], event, handler)</code>.</p>
<p><a name="dom-events-delegated"></a></p>
<h4 id="-dom-">Делегирование DOM-событий</h4>
<p>Делегирование обработки DOM-событий выполняется с помощью метода
<code>liveBindTo([elem], event, handler)</code>. В декларации блока точкой,
зарезервированной для подписки на делегированные DOM-события, служит
свойство <code>live</code> в разделе статических методов блока.</p>
<p><strong>Пример:</strong> Все экземпляры блока <code>menu</code> подписываются на
делегированное DOM-событие <code>click</code> своих элементов <code>item</code>. Метод
<code>_onItemClick</code> экземпляра блока <code>menu</code> будет выполняться при клике
на любой пункт (элемент <code>item</code>) в этом меню. Не имеет значения,
существовал ли этот пункт в момент инициализации экземпляра блока.</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;menu&#39;, {
    _onItemClick : function(e) {
        var clickedItem = $(e.currentTarget); // элемент &#39;item&#39; блока &#39;menu&#39;, на котором слушается DOM-событие &#39;click&#39;
    }
}, {
    live : function() {
        this.liveBindTo(&#39;item&#39;, &#39;click&#39;, function() {
            this._onItemClick();
        });
        return false; // если инициализация блока не может быть отложена
    }
});
</code></pre>
<p>По умолчанию, при наличии в декларации блока свойства <code>live</code>
инициализация экземпляров блока будет <em>отложена</em> до момента, когда
экземпляр блока потребуется в работе
(<a href="#init-live">ленивая инициализация</a>). Таким моментом может стать
DOM-событие на экземпляре блока, на которое выполнена делегированная
подписка, или обращение к экземпляру блока <a href="#ibc">из другого блока</a>.
Если инициализация блока не может быть отложена (требуется
<a href="#init-auto">автоматическая инициализация</a>), следует вернуть <code>false</code>
в результате выполнения функции в значении свойства <code>live</code>.</p>
<p><strong>NB</strong> Функция-обработчик выполняется в контексте ближайшего блока
данного типа на пути распространения DOM-события (снизу вверх
по DOM-дереву).</p>
<p><strong>Удаление подписки</strong> на делегированные DOM-события никогда не
выполняется автоматически. Если подписку необходимо удалить, следует
воспользоваться методом <code>liveUnbindFrom([elem], event, [handler])</code>.</p>
<h4 id="-dom-">Объект DOM-события</h4>
<p>В качестве параметра функции-обработчику передается jQuery-объект,
описывающий DOM-событие — <a href="https://api.jquery.com/category/events/event-object/"><code>{jQuery.Event}</code></a>.</p>
<p>Если DOM-событие было сгенерировано вручную, все параметры, переданные
функции <code>trigger</code> при создании события, будут переданы
функции-обработчику в том же порядке после объекта события.</p>
<p><a name="bem-events"></a></p>
<h3 id="-">БЭМ-события</h3>
<p>В отличие от DOM-событий, БЭМ-события генерируются не на
DOM-элементах, а на <strong>экземплярах блоков</strong>. Элементы блоков не могут
генерировать БЭМ-события.</p>
<p>Чтобы сгенерировать БЭМ-событие, используется метод экземпляра блока
<code>emit(event)</code>.</p>
<p><strong>Пример:</strong> Взаимодействие пользователя с элементом управления блока
(DOM-событие) можно преобразовать в БЭМ-событие на блоке. В
приведенном ниже примере при клике пользователя по кнопке <code>submit</code>
(DOM-событие <code>click</code>) <strong>БЭМ-событие</strong> <code>click</code> генерируется только в
том случае, если у блока в этот момент не выставлен модификатор
<code>disabled</code>:</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;submit&#39;, {
    onSetMod: {
        &#39;js&#39;: {
            &#39;inited&#39;: function() {
                this.bindTo(&#39;click&#39;, this._onClick); // подписка на DOM-событие &quot;click&quot;
            }
        }
    },

    _onClick: function() {
        if(!this.hasMod(&#39;disabled&#39;)) {
            this.emit(&#39;click&#39;); // создание БЭМ-события &quot;click&quot;
        }
    }
});
</code></pre>
<p>Для подписки на БЭМ-события экземпляров блоков используются методы
экземпляра блока <code>on(event, [data], handler, [handlerCtx])</code>.</p>
<p><strong>Пример:</strong> В момент инициализации HTML-формы (экземпляра блока <code>my-form</code>)
выполняется поиск вложенной в форму кнопки <code>submit</code> и подписка на
БЭМ-событие <code>click</code> этой кнопки. В результате при нажатии на кнопку
(экземпляр блока <code>submit</code>) будет выполнен метод <code>_onSubmit</code> формы
(экземпляр блока <code>my-form</code>).</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;my-form&#39;, {
    onSetMod: {
        &#39;js&#39;: {
            &#39;inited&#39;: function() {
                this.findBlockInside(&#39;submit&#39;).on(
                    &#39;click&#39;, // имя БЭМ-события
                    this._onSubmit, // метод экземпляра блока my-form
                    this); // контекст для выполнения _onSubmit — блок my-form
            }
        }
    },

    _onSubmit: function() { /* ... */ }
});
</code></pre>
<p><strong>NB</strong> Если не указывать последний параметр метода <code>on</code> —
<code>[handlerCtx]</code>, контекстом для выполнения функции-обработчика будет
тот блок, в котором возникло БЭМ-событие (в примере выше это блок
<code>submit</code>).</p>
<p><strong>Удаление подписки</strong> на БЭМ-события выполняется автоматически при
уничтожении экземпляра блока. Если требуется удалить подписку вручную
в процессе работы блока, следует использовать метод экземпляра блока
<code>un(event, [handler], [handlerCtx])</code>.</p>
<h4 id="-">События при изменении модификаторов</h4>
<p>Для подписки на БЭМ-события при изменении модификатора блока или элемента используется метод экземпляра блока <code>on</code>. Метод принимает аргументами:</p>
<ul>
<li>объект, описывающий модификатор, на который производится подписка;</li>
<li>функцию обратного вызова, выполняющуюся при установке соответствующего модификатора.</li>
</ul>
<p>Объект, описывающий модификатор, может содержать следующие зарезервированные свойства:</p>
<ul>
<li><code>modName</code> <code>{String}</code> – имя модификатора. Обязательное свойство.</li>
<li><code>modVal</code> <code>{String}</code> – значение модификатора. Обязательное свойство. Со значением <code>*</code> производится
подписка на установку модификатора в <strong>любое</strong> значение. Со значением <code>&#39;&#39;</code> – на <strong>удаление</strong> модификатора.
Подробнее смотрите в разделе <a href="#mods-api-trigger">триггеры на установку модификаторов</a>.</li>
<li><code>elem</code> <code>{String}</code> – имя элемента (для модификаторов элементов).</li>
</ul>
<p><strong>Пример:</strong> В момент инициализации блока <code>monitor</code> выполнятся подписка на:</p>
<ul>
<li><p>установку модификатора <code>m1</code> в любое значение;</p>
<pre><code class="lang-js">BEM.decl(&#39;monitor&#39;, {
  onSetMod: {
      &#39;js&#39;: {
          &#39;inited&#39;: function() {
            block1.on({ modName : &#39;m1&#39;, modVal : &#39;*&#39; }, function() {});
          }
      }
  },
});
</code></pre>
</li>
<li><p>установку модификатора <code>m1</code> в значение <code>v1</code>;</p>
<pre><code class="lang-js">block1.on({ modName : &#39;m1&#39;, modVal : &#39;v1&#39; }, function() {});
</code></pre>
</li>
<li><p>удаление модификатора <code>m1</code>;</p>
<pre><code class="lang-js">block1.on({ modName : &#39;m1&#39;, modVal : &#39;&#39; }, function() {});
</code></pre>
</li>
<li><p>удаление модификатора <code>m1</code> у элемента <code>e1</code>;</p>
<pre><code class="lang-js">block1.on({ elem : &#39;e1&#39;, modName : &#39;m1&#39;, modVal : &#39;&#39; }, function() {});
</code></pre>
</li>
</ul>
<p><strong>NB</strong> В целях оптимизации производительности БЭМ-события при изменении модификаторов генерируются только в случае, если для них есть подписчики.</p>
<p><a name="bem-events-delegated"></a></p>
<h4 id="-">Делегирование БЭМ-событий</h4>
<p>Делегирование БЭМ-событий означает, что блок подписывается на
определенное БЭМ-событие <strong>всех экземпляров</strong> блока с заданным именем
<strong>в пределах заданного контекста</strong>. Подписка на делегированные
БЭМ-события выполняется с помощью статического метода <em>класса блока</em>
<code>on([ctx], event, [data], handler, [handlerCtx])</code>.</p>
<p>Параметры:</p>
<ul>
<li><code>{jQuery} [ctx]</code> — DOM-узел, в пределах которого отслеживаются
БЭМ-события (контейнер). Если не указан, в качестве контейнера
используется весь документ.</li>
<li><code>{String} event</code> — имя БЭМ-события.</li>
<li><code>{Object} [data]</code> — произвольные данные, передаваемые функции-обработчику.</li>
<li><code>{Function} handler</code> — функция-обработчик события.</li>
<li><code>{Object} [handlerCtx]</code> — контекст функции-обработчика
события. Обычно в качестве контекста должен выступать тот экземпляр
блока, который подписывается на БЭМ-событие, а не тот, в котором БЭМ-событие
произошло.</li>
</ul>
<p><strong>Пример:</strong> При инициализации экземпляров блока <code>menu</code> выполняется
подписка на БЭМ-событие <code>click</code> всех ссылок (экземпляров блока
<code>link</code>) в пределах DOM-узла, к которому привязано меню
(<code>this.domElem</code>). В качестве контекста функции-обработчика
передается экземпляр блока, в котором событие будет обрабатываться
(<code>this</code>).
При <a href="#destruct">уничтожении экземпляров блока</a> <code>menu</code> <strong>удаление подписки</strong> на делегированные
БЭМ-события никогда не происходит автоматически. Всегда следует явно удалять подписку
при помощи статического метода блока <code>un([ctx], event, [handler], [handlerCtx])</code>.</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;menu&#39;, {
    onSetMod : {
        &#39;js&#39; : {
            &#39;inited&#39; : function() {
                BEMDOM.blocks[&#39;link&#39;].on( // подписка на БЭМ-событие
                    this.domElem, // контейнер — DOM-узел экземпляра блока menu
                    &#39;click&#39;, // БЭМ-событие
                    this._onLinkClick, // обработчик
                    this); // контекст обработчика — экземпляр блока menu
            },

            &#39;&#39; : function() {
                BEMDOM.blocks[&#39;link&#39;].un( // удаление подписки на БЭМ-событие
                    this.domElem,
                    &#39;click&#39;,
                    this._onLinkClick,
                    this);
            }
        }
    },

    _onLinkClick : function(e) {
        var clickedLink = e.target; // экземпляр блока &#39;link&#39;, на котором произошло БЭМ-событие &#39;click&#39;
    }
});
</code></pre>
<p><strong>NB</strong> Если не указывать параметр <code>[handlerCtx]</code> метода <code>on</code>,
контекстом для функции-обработчика будет тот блок, в котором
<em>возникло</em> БЭМ-событие.</p>
<p><strong>Удаление подписки</strong> на делегированные БЭМ-события никогда не
происходит автоматически. Всегда следует явно удалять подписку при
помощи статического метода блока <code>un([ctx], event, [handler], [handlerCtx])</code>.</p>
<p>Полное описание API для работы с БЭМ-событиями содержится в исходном
коде модулей <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/i-bem.vanilla.js">i-bem</a> и <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js">i-bem__dom</a>.</p>
<p><a name="api"></a></p>
<h3 id="-">Объект БЭМ-события</h3>
<p>В качестве параметра функции-обработчику передается объект,
описывающий БЭМ-событие. Объект БЭМ-события <code>events.Event</code> определен
в <a href="https://github.com/ymaps/modules">ymaps</a>-модуле
<a href="https://github.com/bem/bem-core/blob/v2/common.blocks/events/events.vanilla.js"><code>events</code></a> библиотеки bem-core. Содержит поля:</p>
<ul>
<li><code>target</code> — экземпляр блока, в котором произошло БЭМ-событие.</li>
<li><code>data</code> — произвольные дополнительные данные. Передается в качестве
параметра <code>data</code> в момент подписки на БЭМ-событие или при создании
БЭМ-события блоком.</li>
<li><code>result</code> — последнее значение, возвращенное обработчиком данного
события. Аналогично <a href="https://api.jquery.com/event.result/">jQuery.Event.result</a>.</li>
<li><code>type</code> — тип события. Аналогично
<a href="https://api.jquery.com/event.type/">jQuery.Event.type</a>.</li>
</ul>
<p><a name="states"></a></p>
<h2 id="-">Состояния блока</h2>
<p>Проектируя динамический блок в стиле БЭМ, нужно представить всю логику
изменений, происходящих в нем, как набор <strong>состояний</strong> блока. Тогда
поведение блока определяется <strong>триггерами</strong> — callback-функциями, которые
выполняются при переходе блока из одного состояния в другое.</p>
<p>Такой подход позволяет писать код блока в декларативном стиле как
набор утверждений вида: <code>описание состояния</code> — <code>действия, выполняемые
при переходе в данное состояние</code>.</p>
<p><a name="modifiers"></a></p>
<h3 id="-">Модификаторы</h3>
<p>Согласно БЭМ-методологии, состояние блока и его элементов описывается
<strong>модификаторами</strong>.</p>
<p>Модификатор описывает, в каком из возможных состояний находится
блок. Модификатор представляет собой пару строк: <strong>имя</strong> и
<strong>значение</strong>. Список допустимых значений модификатора описывает
набор состояний блока. Например, для описания размеров блока
можно использовать модификатор <code>size</code> с допустимыми значениями <code>s</code>, <code>m</code> и
<code>l</code>.</p>
<p><strong>Простой модификатор</strong> — частный случай, когда важно только наличие
или отсутствие данного модификатора у блока, а его значение
несущественно. Например, модификатор описывающий состояние «отключен»:
<code>disabled</code>. В <code>i-bem.js</code> представлены как модификаторы с булевым
значением. При выставлении модификатора с неуказанным значением
<code>i-bem.js</code> автоматически присваивает ему значение <code>true</code>.</p>
<p>Каждому блоку можно установить один или несколько модификаторов. Блок
может не иметь модификаторов. Список допустимых модификаторов и их
значений определяет разработчик блока.</p>
<p>В <code>i-bem.js</code> модификаторы устанавливаются при
<a href="#init">инициализации экземпляра блока</a> (если модификаторы и их
значения указаны в атрибуте <code>class</code> соответствующего HTML-элемента).</p>
<p><strong>NB</strong> Если модификаторы блока указаны в HTML-элементе, при
инициализации блока триггеры на установку данных модификаторов <em>не
выполняются</em>. Экземпляр блока в этом случае получает начальное
состояние, а не меняет его.</p>
<p>Модификаторы могут добавляться, удаляться и менять значения:</p>
<ul>
<li>в ходе выполнения кода блока (например, в качестве реакции на <a href="#dom-events">DOM-события</a>);</li>
<li>по запросу из другого блока (см. раздел <a href="#ibc">Взаимодействие блоков</a>).</li>
</ul>
<p>При добавлении, удалении и изменении значений модификаторов выполняются триггеры.</p>
<p><a name="mods-api"></a></p>
<h4 id="-">Управление модификаторами</h4>
<p>Экземпляр блока предоставляет методы для установки, проверки значений
и удаления модификаторов данного экземпляра.</p>
<p><strong>NB</strong> Модификаторы нельзя устанавливать, напрямую меняя CSS-классы на
соответствующем DOM-узле. Для изменения значений модификаторов следует
использовать описанный ниже API, предоставляемый <code>i-bem.js</code>.</p>
<p><strong>Пример:</strong> Экземпляр блока <code>square</code> может по клику на DOM-элементе
блока переключаться между значениями <code>green</code> и <code>red</code> модификатора
<code>color</code>, если не выставлен модификатор <code>disabled</code>:</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;square&#39;, {
    onSquareClick: function(e) {
        if(!this.hasMod(&#39;disabled&#39;)) {
            this.toggleMod(&#39;color&#39;, &#39;green&#39;, &#39;red&#39;);
        }
    }
});
</code></pre>
<p>Эти же методы используются для управления модификаторами элементов
блока. Для этого в качестве первого (необязательного) параметра
указывается ссылка на объект элемента (а не имя элемента).</p>
<p><strong>Пример:</strong> Блок <code>searchbox</code> по клику может выставлять своему элементу
<code>input</code> простой модификатор <code>clean</code> (подразумеваемое значение —
<code>true</code>):</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;searchbox&#39;, {
    _onClick: function() {
        this.setMod(this.elem(&#39;input&#39;), &#39;clean&#39;);
    }
});
</code></pre>
<p><strong>NB</strong> При управлении модификаторами элементов в качестве первого
параметра необходимо указывать ссылку на <strong>DOM-узел элемента</strong>, а не
имя элемента. В противном случае возникла бы неоднозначность:
имеется в виду установка блоку <em>модификатора</em> <code>input</code> со значением
<code>clean</code> или установка элементу <code>input</code> <em>простого модификатора</em> <code>clean</code>.</p>
<p>Полное описание API для управления модификаторами приведено в
исходном коде модулей <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/i-bem.vanilla.js">i-bem</a> и <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js">i-bem__dom</a>.</p>
<p><a name="mods-api-trigger"></a></p>
<h3 id="-">Триггеры на установку модификаторов</h3>
<p>Выполнение триггеров на установку модификаторов разбито на две фазы:</p>
<ol>
<li><strong>До установки модификатора</strong>. Эта фаза зарезервирована для
возможности <strong>отменить</strong> установку модификатора. Если хотя бы один
из триггеров, выполняемых в этой фазе, вернет <code>false</code>,
установки модификатора не произойдет.</li>
<li><strong>После установки модификатора</strong>. Триггеры, выполняемые в этой
фазе, уже не могут отменить установку модификаторов.</li>
</ol>
<p>Триггеры могут быть привязаны к следующим типам изменений значений модификаторов:</p>
<ol>
<li>установка <em>любого</em> модификатора в <em>любое</em> значение;</li>
<li>установка <em>конкретного</em> модификатора <code>modName</code> в <em>любое</em> значение (в том числе
установка простого модификатора в значение <code>true</code>);</li>
<li>установка <em>конкретного</em> модификатора <code>modName</code> в <em>конкретное</em> значение <code>modVal</code>;</li>
<li>установка модификатора в значение <code>&#39;&#39;</code> (пустая строка), что
эквивалентно удалению модификатора или установке простого
модификатора в значение <code>false</code>.</li>
</ol>
<p>При установке модификатора <code>modName</code> в значение <code>modVal</code> триггеры
каждой фазы (если они определены) вызываются в том порядке, в котором они
перечислены в приведенном выше списке событий (от общего к частному).</p>
<p>Таким образом, при определении триггера пользователь указывает:</p>
<ul>
<li>фазу выполнения (до или после установки модификатора);</li>
<li>тип события (имя и устанавливаемое значение модификатора).</li>
</ul>
<p><a name="mods-api-trigger-phase"></a></p>
<h4 id="-">Фазы выполнения</h4>
<p>Наличие дополнительной фазы, предшествующей установке модификатора, позволяет
произвести некоторые проверки без риска повлиять на логику, связанную с установкой модификатора. Например, если существуют взаимоисключающие модификаторы, перед установкой одного из них логично проверить не установлен ли другой.</p>
<p>В блоке <code>checkbox-group</code> библиотеки <code>bem-components</code> перед установкой модификатора <code>focused</code> производится проверка на наличие модификатора <code>disabled</code>:</p>
<pre><code class="lang-js">provide(BEMDOM.decl(this.name, /** @lends checkbox-group.prototype */{
    beforeSetMod : {
        &#39;focused&#39; : {
            &#39;true&#39; : function() {
                return !this.hasMod(&#39;disabled&#39;);
            }
        }
    },

    onSetMod : {
        &#39;focused&#39; : { /* ... */}
    }
}));
</code></pre>
<p>Если триггер для фазы, предшествующей установке (<code>beforeSetMod</code>), возвращает <code>false</code>, установка модификатора не производится.</p>
<p><a name="mods-api-trigger-decl"></a></p>
<h4 id="-">Декларация триггеров</h4>
<p>Триггеры, выполняемые при установке модификаторов, описываются в
декларации блока. Для этого в хэше методов экземпляра блока
зарезервированы свойства:</p>
<ul>
<li><code>beforeSetMod</code> — триггеры, вызываемые до установки
<strong>модификаторов блока</strong>;</li>
<li><code>beforeElemSetMod</code> — триггеры, вызываемые до установки
<strong>модификаторов элементов</strong>;</li>
<li><code>onSetMod</code> — триггеры, вызываемые после установки
<strong>модификаторов блока</strong>;</li>
<li><code>onElemSetMod</code> — триггеры, вызываемые после установки
<strong>модификаторов элементов</strong> блока.</li>
</ul>
<pre><code class="lang-js">modules.define(&#39;i-bem__dom&#39;, function(provide, BEMDOM) {

provide(BEMDOM.decl(/* селектор блока */,
    {
        /* методы экземпляра */
        beforeSetMod: { /* триггеры до установки модификаторов блока*/}
        beforeElemSetMod: { /* триггеры до установки модификаторов элементов*/}
        onSetMod: { /* триггеры после установки модификаторов блока */ }
        onElemSetMod: { /* триггеры после установки модификаторов элементов */ }
    },
    {
        /* статические методы */
    }
));
});
</code></pre>
<p>Значение свойств <code>beforeSetMod</code> и <code>onSetMod</code> — хэш, связывающий
изменения модификаторов с триггерами. В качестве параметров триггерам
передаются:</p>
<ul>
<li>имя модификатора;</li>
<li>выставляемое значение модификатора;</li>
<li>предшествующее (для <code>beforeElemSetMod</code>) или текущее (для <code>onElemSetMod</code>) значение модификатора.</li>
</ul>
<pre><code class="lang-js">{
    &#39;mod1&#39;: function(modName, modVal, prevModVal) { /* ... */ }, // установка mod1 в любое значение
    &#39;mod2&#39;: {
        &#39;val1&#39;: function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val1
        &#39;val2&#39;: function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 в значение val2
        &#39;&#39;: function(modName, modVal, prevModVal) { /* ... */ } // триггер на удаление модификатора mod2
    &#39;mod3&#39;: {
        &#39;true&#39;: function(modName, modVal, prevModVal) { /* ... */ }, // триггер на установку простого модификатора mod3
        &#39;&#39;: function(modName, modVal, prevModVal) { /* ... */ }, // триггер на удаление простого модификатора mod3
    },
    &#39;*&#39;: function(modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора в любое значение
}
</code></pre>
<p>Для триггера на установку любого модификатора блока в любое значение
существует сокращенная форма записи:</p>
<pre><code class="lang-js">beforeSetMod: function(modName, modVal, prevModVal) { /* ... */ }
onSetMod: function(modName, modVal, prevModVal) { /* ... */ }
</code></pre>
<p>Для свойств <code>beforeElemSetMod</code> и <code>onElemSetMod</code> в хэш значений
добавляется дополнительный уровень вложенности — <strong>элемент</strong>. В этих
свойствах описываются триггеры на установку модификаторов элементов.
В качестве параметров триггеру передаются:</p>
<ul>
<li>имя элемента;</li>
<li>имя модификатора;</li>
<li>выставляемое значение модификатора;</li>
<li>предшествующее (для <code>beforeElemSetMod</code>) или текущее (для <code>onElemSetMod</code>) значение модификатора.</li>
</ul>
<pre><code class="lang-js">{
    &#39;elem1&#39;: {
        &#39;mod1&#39;: function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod1 элемента elem 1 в любое значение
        &#39;mod2&#39;: {
            &#39;val1&#39;: function(elem, modName, modVal, prevModVal) { /* ... */ }, // триггер на установку mod2 элемента elem1 в значение val1
            &#39;val2&#39;: function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку mod2 элемента elem1 в значение val2
            }
        },
    &#39;elem2&#39;: function(elem, modName, modVal, prevModVal) { /* ... */ } // триггер на установку любого модификатора элемента elem2 в любое значение
}
</code></pre>
<p>Сокращенная запись для триггера на установку любого модификатора элемента <code>elem1</code> в любое значение:</p>
<pre><code class="lang-js">beforeElemSetMod: { &#39;elem1&#39;: function(elem, modName, modVal, prevModVal) { /* ... */ } }
onElemSetMod: { &#39;elem1&#39;: function(elem, modName, modVal, prevModVal) { /* ... */ } }
</code></pre>
<h4 id="-">Примеры триггеров</h4>
<p>Типовая задача триггеров, вызываемых после установки модификатора или
изменения его значения (свойство <code>onSetMod</code>) — выполнить операции над
DOM-узлом блока, необходимые для перехода в новое состояние.</p>
<p><strong>Пример:</strong> Экземпляр блока <code>input</code> при установке простого
модификатора <code>focused</code> (в значение <code>true</code>) очищает поле ввода —
заменяет пустой строкой текст DOM-узла блока.</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;input&#39;, {
    onSetMod : {
        &#39;focused&#39; : {
            &#39;true&#39; : function() {
                this.domElem.val(&#39;&#39;); // очистить поле ввода
            }
        }
    }
});
</code></pre>
<p>Триггеры, выполняемые перед установкой модификатора (свойство
<code>beforeSetMod</code>), необходимы для проверки текущего состояния экземпляра
блока и возможности отменить переход в другое состояние.</p>
<p><strong>Пример:</strong> Экземпляр блока <code>input</code> перед установкой простого
модификатора <code>focused</code> проверяет, не выставлен ли у него модификатор
<code>disabled</code>. Если <code>disabled</code> выставлен, будет возвращено значение <code>false</code> и
установки модификатора <code>focused</code> не произойдет.</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;input&#39;, {
    beforeSetMod : {
        &#39;focused&#39; : {
            &#39;true&#39; : function() {
                return !this.hasMod(&#39;disabled&#39;); // вернет false, если disabled
            }
        }
    }
});
</code></pre>
<p><a name="init"></a></p>
<h3 id="-">Инициализация</h3>
<p>Инициализация блока — это создание в памяти браузера JS-объекта,
соответствующего экземпляру блока. Инициализация экземпляров блоков выполняется
методом <code>init()</code> модуля <code>i-bem__dom</code> на заданном фрагменте DOM-дерева.</p>
<p>Каждому экземпляру блока можно приписать три состояния:</p>
<ul>
<li>экземпляр блока не инициализирован (JS-объект не создан);</li>
<li>экземпляр блока инициализирован (JS-объект создан в памяти браузера);</li>
<li>экземпляр блока уничтожен (удалены все ссылки на JS-объект экземпляра
блока, и он может быть удален сборщиком мусора).</li>
</ul>
<p>В <code>i-bem.js</code> эти состояния экземпляра блока описываются с помощью служебного
модификатора <code>js</code>.</p>
<ul>
<li>До инициализации экземпляр блока не имеет модификатора <code>js</code>.</li>
</ul>
<pre><code class="lang-html">&lt;div class=&quot;my-block i-bem&quot; data-bem=&quot;...&quot; &gt;...&lt;/div&gt;
</code></pre>
<ul>
<li>В момент инициализации экземпляру блока устанавливается модификатор
<code>js</code> в значении <code>inited</code>.</li>
</ul>
<pre><code class="lang-html">&lt;div class=&quot;my-block i-bem my-block_js_inited&quot; data-bem=&quot;...&quot;&gt;...&lt;/div&gt;
</code></pre>
<ul>
<li>Если в процессе работы удаляется фрагмент DOM-дерева (при помощи
метода <code>destruct</code> модуля <code>i-bem__dom</code>), то вместе с
ним удаляются экземпляры блоков, все HTML-элементы которых находятся
в этом фрагменте. Перед удалением экземпляра блока модификатор <code>js</code>
удаляется.</li>
</ul>
<p><strong>NB</strong> Если экземпляр блока был
<a href="#distrib-block">привязан к нескольким HTML-элементам</a>, блок будет существовать,
пока в HTML-дереве сохраняется хотя бы один элемент, с которым он
связан.</p>
<p>Если на HTML-элементе размещено несколько экземпляров других блоков, то
инициализация одного из них (появление модификатора <code>my-block_js_inited</code>)
не влияет на инициализацию остальных.</p>
<p><strong>Пример:</strong> На HTML-элементе инициализирован только экземпляр блока <code>my-block</code>.
Экземпляр блока <code>lazy-block</code> не инициализирован:</p>
<pre><code class="lang-html">&lt;div class=&quot;my-block my-block_js_inited lazy-block i-bem&quot;
    data-bem=&#39;{ &quot;my-block&quot;: {}, &quot;lazy-block&quot;: {} }&#39; &gt;
    ...
&lt;/div&gt;
</code></pre>
<p><strong>NB</strong> Наличие модификатора <code>js</code> позволяет писать разные CSS-стили для
блока в зависимости от того, инициализирован он или нет.</p>
<h4 id="-">Конструктор экземпляра блока</h4>
<p>На изменение значений модификатора <code>js</code> можно назначать триггеры так
же, как и для любых других модификаторов блока.</p>
<p>Триггер на установку модификатора <code>js</code> в значение <code>inited</code> выполняется
при создании блока. Этот триггер можно считать <strong>конструктором
экземпляра блока</strong>:</p>
<pre><code class="lang-js">onSetMod: {
    &#39;js&#39;: {
        &#39;inited&#39;: function() { /* ... */ } // конструктор экземпляра блока
    }
}
</code></pre>
<p><a name="destruct"></a></p>
<h4 id="-">Деструктор экземпляра блока</h4>
<p>Моментом удаления блока является момент уничтожения всех ссылок на
JS-объект блока, после чего он может быть удален из памяти браузера
сборщиком мусора.</p>
<p>Триггер на удаление модификатора <code>js</code> (установку в пустое значение
<code>&#39;&#39;</code>) выполняется перед удалением блока. Такой триггер можно считать
<strong>деструктором экземпляра блока</strong>.</p>
<pre><code class="lang-js">onSetMod: {
    &#39;js&#39;: {
        &#39;&#39;: function() { /* ... */ } // деструктор экземпляра блока
    }
}
</code></pre>
<p><a name="init-wave"></a></p>
<h4 id="-">Волны инициализации</h4>
<p>Инициализация экземпляров блоков, присутствующих на странице, не
обязательно происходит одновременно. Блоки могут добавляться в ходе
работы (например, за счет динамической генерации HTML на основе
данных, полученных от сервера) или инициализироваться только по запросу.
Инициализация очередной группы блоков называется <strong>волной
инициализации</strong>.</p>
<p>Новая волна инициализации создается в следующих случаях:</p>
<ul>
<li><a href="#init-auto">Автоматическая инициализация всех блоков в документе по событию <code>domReady</code></a>;</li>
<li><a href="#init-live">Инициализация блока по событию на DOM-узле</a> (ленивая инициализация);</li>
<li><a href="#init-ajax">Явный вызов инициализации блоков на указанном фрагменте DOM-дерева</a>.</li>
</ul>
<p><a name="init-auto"></a></p>
<h4 id="-">Автоматическая инициализация</h4>
<p>Фреймворк <em>i-bem.js</em> позволяет автоматически инициализировать все
блоки, имеющие DOM-представление (привязанные к DOM-элементам на
странице) в момент наступления DOM-события <code>domReady</code>. Чтобы включить
автоматическую инициализацию, необходимо задекларировать на странице
блок <code>i-bem</code> с модификатором <code>init</code> в значении <code>auto</code>.</p>
<p><strong>Пример файла</strong> <code>.deps.js</code>:</p>
<pre><code class="lang-js">({
    shouldDeps: [
        {
            block: &#39;i-bem&#39;,
            elem: &#39;dom&#39;,
            mods: { &#39;init&#39;: &#39;auto&#39; }
        }
    ]
})
</code></pre>
<p>При автоматической инициализации в памяти браузера будут созданы
JS-объекты для всех DOM-узлов, в атрибуте <code>class</code> которых указан
<code>i-bem</code>. Инициализация выполняется функцией <code>init</code> модуля
<a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js">i-bem__dom</a>.</p>
<p><a name="init-live"></a></p>
<h4 id="-">Инициализация по событию (ленивая инициализация)</h4>
<p>Если на странице размещено много экземпляров блоков, автоматическая инициализация
всех блоков в момент загрузки страницы нежелательна, так как она
увеличивает время загрузки и объем памяти, затрачиваемой браузером.</p>
<p>В этом случае имеет смысл инициализировать JS-объекты
только в тот момент, когда их функциональность потребуется
пользователю: например, по клику на блоке. Такая инициализация
называется <strong>ленивой</strong> или <strong>live-инициализацией</strong>.</p>
<p>Для описания условий ленивой инициализации зарезервировано свойство
<code>live</code> в разделе статических методов декларации блока. Свойство <code>live</code>
может принимать два типа значений:</p>
<ul>
<li><code>Boolean</code><br/>
Имеет смысл только значение <code>true</code>: экземпляры
блоков данного класса будут инициализированы только при попытке
получить соответствующий экземпляр (см. раздел <a href="#ibc">Взаимодействие блоков</a>).</li>
</ul>
<pre><code class="lang-js">modules.define(&#39;i-bem__dom&#39;, function(provide, BEMDOM) {

BEMDOM.decl(&#39;my-block&#39;,
    {
        onSetMod: {
            &#39;js&#39;: {
                &#39;inited&#39;: function() { /* ... */ } // этот код будет выполняться
                                                   // при первом обращении к экземпляру блока
            }
        }
    },
    { live: &#39;true&#39; } // статические методы и свойства
);

provide(BEMDOM);

});
</code></pre>
<ul>
<li><code>Function</code><br/>
Функция, которую нужно выполнить при попытке
инициализации <strong>первого экземпляра</strong> блока заданного класса. Если
функция возвращает значение <code>false</code>, экземпляры блоков будут
инициализироваться <a href="#init-auto">автоматически</a>.</li>
</ul>
<p>Если необходимо инициализировать экземпляры блока по наступлению
DOM- или БЭМ-событий, в теле функции следует выполнить подписку на
<a href="#delegated-events">делегированные события</a>. Возможна инициализация
по:</p>
<ul>
<li>DOM-событию на DOM-узле блока и вложенных элементах;</li>
<li>БЭМ-событию на вложенных блоках.</li>
</ul>
<p><strong>Пример:</strong> Экземпляры блока <code>my-block</code> будут инициализироваться по
DOM-событию <code>click</code> на DOM-узле блока. По каждому DOM-событию
<code>click</code> будет вызываться метод экземпляра блока <code>_onClick</code>:</p>
<pre><code class="lang-js">modules.define(&#39;i-bem__dom&#39;, function(provide, BEMDOM) {

BEMDOM.decl(&#39;my-block&#39;,
    {
        onSetMod: {
            &#39;js&#39;: {
                &#39;inited&#39;: function() { /* ... */ } // выполняется при первом DOM-событии &#39;click&#39;
            }
        },

        _onClick: function() { /* ... */ } // выполняется при каждом DOM-событии &#39;click&#39;
    },
    {
        live: function() {
            this.liveBindTo(&#39;click&#39;, function() {
                this._onClick(); // в момент клика будет создан экземпляр блока и вызван его метод _onClick
            });
        }
    }
);

provide(BEMDOM);

});
</code></pre>
<p>Если необходимо воспользоваться делегированными событиями в блоке,
но инициализацию блока нельзя отложить (экземпляры блока должны быть
инициализированы немедленно после загрузки страницы), следует вернуть
значение <code>false</code>:</p>
<pre><code class="lang-js">modules.define(&#39;i-bem__dom&#39;, function(provide, BEMDOM) {

BEMDOM.decl(&#39;my-block&#39;,
    {
        onSetMod: {
            &#39;js&#39;: {
                &#39;inited&#39;: function() { /* ... */ } // будет выполнена по наступлении domReady
            }
        },

        _onClick: function() { /* ... */ } // будет выполняться каждый
                                           // раз при наступлении DOM-события &#39;click&#39;
    },
    {
        live: function() {
            this.liveBindTo(&#39;click&#39;, function() { this._onClick() });
            return false; // экземпляры блоков будут инициализированы автоматически
        }
    }
);

provide(BEMDOM);

});
</code></pre>
<p>Полный список хелперов для подписки на делегированные события
приведен в исходном коде модуля <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js">i-bem__dom</a>.</p>
<p><strong>NB</strong> Свойство <code>live</code> задает ленивую инициализацию для <em>всех
экземпляров</em> соответствующего блока, так как технически относится
к статическим методам класса блока. Поэтому даже если свойство <code>live</code>
задекларировано для блока с определенным значением модификатора, оно
будет применено ко всем блокам данного класса вне зависимости от
модификаторов.</p>
<p><a name="init-ajax"></a></p>
<h4 id="-dom-">Инициализация блоков на фрагменте DOM-дерева</h4>
<p>Процедура инициализации JS-объектов может быть вызвана
явно для указанного фрагмента DOM-дерева. Часто такая необходимость
возникает при разработке AJAX-интерфейсов, когда нужно <a href="#dynamic">динамически встроить</a> в страницу новые экземпляры блоков либо обновить существующие.</p>
<p>В <code>i-bem.js</code> следующие функции выполняют динамическую инициализацию блоков:</p>
<ul>
<li>Инициализация/уничтожение блоков на указанном фрагменте DOM-дерева
(<code>init</code>);</li>
<li>Добавление/замена фрагмента DOM-дерева с одновременной
инициализацией блоков на обновленном фрагменте (<code>update</code>, <code>replace</code>,
<code>append</code>, <code>prepend</code>, <code>before</code>, <code>after</code>).</li>
</ul>
<p><a name="destruct-dom"></a></p>
<h4 id="-dom-">Удаление блоков на фрагменте DOM-дерева</h4>
<p>Как и процедура инициализации блоков, процедура удаления может быть вызвана явно для заданного фрагмента DOM-дерева. Например, при разработке AJAX-интерфейсов, для динамического удаления экземпляров блоков со страницы.</p>
<p>Явный вызов процедуры гарантирует корректное удаление:</p>
<ul>
<li>вложенных DOM-узлов;</li>
<li>блоков, примешанных к другим блокам.</li>
</ul>
<p>Для явного вызова процедуры удаления служит статичесикий метод <code>destruct</code>, реализованный в элементе <code>dom</code> блока <code>i-bem</code> библиотеки <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js#L970">bem-core</a>.</p>
<p>Метод принимает два аргумента:</p>
<ul>
<li><code>ctx</code> <code>{jQuery}</code> – корневой DOM-элемент. Удаляется со всем вложенными DOM-узлами.</li>
<li><code>excludeSelf</code> <code>Boolean</code> – не удалять корневой DOM-элемент если значение <code>true</code>. По умолчанию <code>false</code>.</li>
</ul>
<p>Например, в блоке <a href="https://github.com/bem/bem-components/blob/v2/common.blocks/popup/_target/popup_target_anchor.js">popup_target_anchor</a> библиотеки <code>bem-components</code> <code>destruct</code> используется приватным методом <code>_onPopupAnchorDestruct</code> для удаления текущего DOM-элемента при удалении якоря попапа:</p>
<pre><code class="lang-js">_onPopupAnchorDestruct : function() {
    BEMDOM.destruct(this.domElem);
}
</code></pre>
<p><a name="init-bem"></a></p>
<h4 id="-dom-">Инициализация и удаление блоков без DOM-представления</h4>
<p>Чтобы создать JS-объект для блока, не имеющего DOM-представления (не
привязанного к HTML-элементу), необходимо вызвать метод <code>create</code>,
который вернет экземпляр блока указанного класса.</p>
<p><strong>Пример:</strong> В момент инициализации экземпляра блока с DOM-представлением
<code>container</code> создается экземпляр блока без DOM-представления <code>router</code>. Экземпляр блока
<code>container</code> затем будет обращаться к созданному им экземпляру блока
<code>router</code> при вызове метода <code>onRequest</code>:</p>
<pre><code class="lang-js">modules.define(&#39;i-bem__dom&#39;, &#39;i-bem&#39;, function(provide, BEM, BEMDOM) {

BEMDOM.decl(&#39;container&#39;, {
    onSetMod: {
        &#39;js&#39;: {
            &#39;inited&#39;: function() {
                this._router = BEM.create(&#39;router&#39;); // создание экземпляра блока router
            }
        }
    },

    onRequest: function() {
        this._router.route(/* ... */) // вызов метода экземпляра блока router
    }
});

provide(BEMDOM);

});
</code></pre>
<p><strong>Пример:</strong> Блок без DOM-представления реализован в виде простого
<a href="https://github.com/ymaps/modules">ymaps-модуля</a>, без использования модуля <code>i-bem</code>. Такой блок
используется как обычный ymaps-модуль (нет необходимости создавать
экземпляр блока):</p>
<pre><code class="lang-js">modules.define(&#39;i-bem__dom&#39;, &#39;router&#39;, function(provide, BEMDOM, router) {

BEMDOM.decl(&#39;container&#39;, {
    onRequest: function() {
        router.route(/* ... */); // вызов метода блока router
    }
});

provide(BEMDOM, router);

});
</code></pre>
<p><strong>Удаление</strong> экземпляров блоков без DOM-представления не может быть
выполнено автоматически и является ответственностью
разработчика. Блоки без DOM-представления представляют собой обычные
JS-объекты и удаляются в момент удаления всех ссылок на объект блока.</p>
<p><strong>Пример:</strong> При удалении экземпляра блока <code>container</code> удаляется созданный им в
процессе работы экземпляр блока без DOM-представления <code>router</code>.</p>
<pre><code class="lang-js">modules.define(&#39;i-bem__dom&#39;, &#39;i-bem&#39;, function(provide, BEM, BEMDOM) {

BEMDOM.decl(&#39;container&#39;, {
    onSetMod : {
        &#39;js&#39; : {
            &#39;&#39; : function() {
                delete this._router; // удаление экземпляра блока router
            }
        }
    }
});

provide(BEMDOM);

});
</code></pre>
<p><a name="ibc"></a></p>
<h2 id="-">Взаимодействие блоков</h2>
<p>В рамках БЭМ-методологии блоки следует разрабатывать так,
чтобы по возможности исключить зависимость состояний одних
блоков от других. Однако на практике идеал полной независимости блоков
недостижим.</p>
<p>Взаимодействие блоков может быть реализовано двумя способами:</p>
<ul>
<li>с помощью подписки на <a href="#bem-events">БЭМ-события</a> других экземпляров
блоков или подписки на <a href="#bem-events-delegated">делегированные БЭМ-события</a>;</li>
<li>с помощью непосредственного вызова методов других экземпляров
блоков или статических методов класса другого блока.</li>
</ul>
<p><strong>NB</strong> Не используйте <a href="#dom-events">DOM-события</a> для
организации взаимодействия между блоками. DOM-события предназначены
только для реализации внутренних процедур блока.</p>
<p>Для реализации взаимодействия блоков <code>i-bem.js</code> предоставляет API:</p>
<ul>
<li><a href="#api-find">Поиск экземпляров блоков в DOM-дереве</a>;</li>
<li><a href="#api-nodom">Доступ к экземплярам блоков без DOM-представления</a>;</li>
<li><a href="#api-calss">Доступ к классам блоков</a>.</li>
</ul>
<p><a name="api-find"></a></p>
<h3 id="-dom-">Поиск экземпляров блоков в DOM-дереве</h3>
<p>Обращение к другому блоку в <code>i-bem.js</code> выполняется из текущего блока,
размещенного на определенном узле DOM-дерева. Поиск других блоков в
DOM-дереве может вестись по трем направлениям (осям) относительно
DOM-узла текущего блока:</p>
<ul>
<li><strong>Внутри блока</strong> — на DOM-узлах, вложенных в DOM-узел текущего блока.</li>
<li><strong>Снаружи блока</strong> — на DOM-узлах, потомком которых является DOM-узел
текущего блока. Необходимость в таком поиске может свидетельствовать
о неудачной архитектуре интерфейса.</li>
<li><strong>На себе</strong> — на том же DOM-узле, на котором размещен текущий
блок. Это актуально в случае <a href="#html-mixes">размещения нескольких JS-блоков на одном DOM-узле</a> (микс).</li>
</ul>
<p><strong>Пример</strong>: При переключении модификатора <code>disabled</code> экземпляр блока
<code>attach</code> находит вложенный в него блок <code>button</code> и переключает его
модификатор <code>disabled</code> в то же значение, которое получил сам:</p>
<pre><code class="lang-js">modules.define(&#39;i-bem__dom&#39;, function(provide, BEMDOM) {

BEMDOM.decl(&#39;attach&#39;, {
    onSetMod: {
        &#39;disabled&#39;: function(modName, modVal) {
            this.findBlockInside(&#39;button&#39;).setMod(modName, modVal);
        }
    }
});

provide(BEMDOM);

});
</code></pre>
<p>Полный список методов для поиска блоков приведен
в исходном коде модуля <a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js">i-bem__dom</a>.</p>
<p><strong>NB</strong> Не используйте jQuery-селекторы для поиска блоков и элементов.
<code>i-bem.js</code> предоставляет высокоуровневое API для доступа к DOM-узлам
блоков и элементов. Обращение к DOM-дереву в обход этого API делает
код менее устойчивым к изменениям БЭМ-библиотек и может привести к
возникновению сложно обнаруживаемых ошибок.</p>
<p><a name="api-nodom"></a></p>
<h3 id="-dom-">Доступ к экземплярам блоков без DOM-представления</h3>
<p>При создании экземпляра блока без DOM-представления необходимо
позаботиться о том, чтобы ссылка на этот экземпляр была доступна
блокам, которым потребуется взаимодействовать с ним. Подробности и
пример см. в разделе <a href="#init-bem">Инициализация и удаление блоков без DOM-представления</a>.</p>
<p><a name="api-class"></a></p>
<h3 id="-">Доступ к классам блоков</h3>
<p>JS-компоненты, соответствующие всем блокам («классы» блоков), хранятся
в структуре данных <code>BEM.blocks</code>. Классы блоков,
<a href="#i-blocks">не привязанных к DOM-дереву</a>, также размещены в этой
структуре данных. При необходимости доступа к таким блокам следует
использовать конструкцию:</p>
<pre><code class="lang-js">BEM.blocks[&#39;name&#39;]
</code></pre>
<p>где <code>name</code> — имя блока.</p>
<p>Доступ к классам блоков необходим для решения двух основных задач:</p>
<ul>
<li><a href="#bem-events-delegated">делегирование БЭМ-событий</a>;</li>
<li>вызов статического метода класса.</li>
</ul>
<p><strong>Пример:</strong> Вызов статического метода <code>close</code> блока <code>popup</code> — закрыть
все попапы на странице:</p>
<pre><code class="lang-js">BEMDOM.decl(&#39;switcher&#39;, {
    onSetMod : {
        &#39;popup&#39; : {
            &#39;disabled&#39; : function() {
                BEM.blocks[&#39;popup&#39;].close();
            }
        }
    }
});
</code></pre>
<p><a name="docs"></a></p>
<h2 id="-">Что дальше?</h2>
<p>Общую информацию о БЭМ-методологии, инструментарии, новостях в мире
БЭМ можно найти на сайте <a href="https://ru.bem.info/">bem.info</a>.</p>
<p>Полную информацию обо всех методах API <code>i-bem.js</code> можно найти в
исходном коде, который сопровождается структурированными комментариями
в формате JSDoc:</p>
<ul>
<li><a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/i-bem.vanilla.js">i-bem</a>;</li>
<li><a href="https://github.com/bem/bem-core/blob/v2/common.blocks/i-bem/__dom/i-bem__dom.js">i-bem__dom</a>.</li>
</ul>
<p>Задать вопрос опытным пользователям и разработчикам <code>i-bem.js</code> и
следить за текущими обсуждениями можно в социальных сетях:</p>
<ul>
<li><a href="http://clubs.ya.ru/bem/">Клуб в Я.ру</a>;</li>
<li><a href="https://www.facebook.com/#!/groups/209713935765634/">Группа в Facebook</a>;</li>
<li><a href="https://twitter.com/bem_ru">Twitter</a>.</li>
</ul>
<p>Прочитать о принципах работы <code>i-bem.js</code> в другом изложении, найти
образцы его применения и пошаговые инструкции на примере простых
проектов можно в статьях:</p>
<ul>
<li><a href="https://ru.bem.info/articles/bem-js-main-terms/">JavaScript по БЭМ: основные понятия</a>;</li>
<li><a href="https://github.com/varya/bem-js-tutorial">Tutorial on JavaScript in BEM terms</a>;</li>
<li><a href="http://habrahabr.ru/post/162385/">Попробуй БЭМ на вкус!</a>;</li>
<li><a href="https://ru.bem.info/articles/firm-card-story/">БЭМ-приложение на Leaflet и API 2GIS</a>.</li>
</ul>
<p><strong>NB</strong> Обратите внимание, что в перечисленных статьях может
использоваться устаревший синтаксис, не соответствующий текущей версии
<code>i-bem.js</code>, включенной в <code>bem-core</code>.</p>
</div></div></div></div><div class="footer"></div><script src="/_index.js"></script></body></html>